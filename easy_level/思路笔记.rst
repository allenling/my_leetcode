善用简单的数学推导
===================

比如, 分解一个整数位多个(大于等于2个)的和，并且多个数的乘积最大。

首先将一个数分解成两个数的和，乘积最大肯定是中位数相乘，简单的证明就是n**2-j**2 > (n+j)(n-j)，n位中位数

所以对中位数n进行再次中位数分解，就可以得到每次乘积最大，最后乘积肯定是最大的

如一个偶数，x，分解成两个数相加，有x=n+n, 乘积最大值肯定是n**2，之后对n继续求中位数，奇数的话是x/2的向上求整+x/2向下求整，证明跟上面一样

所以我们只需要对n进行不断的中位数分解就可以了。

例如 10 = 5+5 = 2+3+2+3 = 2*3*2*3 = 36 == 3+7 =(3+3+2+2)=3* 2 *2 * 3

一般涉及到运算的都是二进制位运算
============================

一般涉及到二叉树的，都是递归
========================

因为我不喜欢递归，可以写成非递归的形式

二叉树的深度的问题
---------------

**试探法**

从左到右遍历

1. 试探走下一步，深度先加1

2. 若没有下一步，深度减1，这样深度就回退到父节点的深度

3. 假设最大深度是j，当前node深度是n，将当前node的left和right放入列表，开始循环。

4. 当前列表为[left, right], 先pop left，深度加1，此时深度是n+1，若left是None，则回退一步，则当前深度依然是n, 最大深度是max(j, n)

5. 然后pop right，深度加1，此时深度是n+1，若left是None，则回退一步，则当前深度依然是n，最大深度是max(j, n)

6. 若当前是右节点，也就是右节点是None的时候，说明该节点是父节点的最后一个节点了，需要试探父节点的兄弟节点了，所以需要将当前深度设置为父节点的父节点的深度，父节点的父节点深度位当前深度再减1。

7. 所以需要记录当前是不是右节点回退，当前是右节点回退的条件是左节点也已经回退过一次了，也就是已经经历过一次(n+1)-1了，所以可以在左节点回退的时候设置一个标识位，is_right=True, 回退的时候
判断is_right是不是True，如果是，则回退到父节点的父节点的深度。而每次可以走下一步的时候，也就是node is not None的时候，都是优先对左节点进行回退，所以此时把is_right设置位False






